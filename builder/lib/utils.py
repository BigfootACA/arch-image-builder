import os
import io
import shlex
import shutil
import typing
from logging import getLogger
log = getLogger(__name__)


def str_find_all(
	orig: str,
	keys: list[str] | tuple[str] | str,
	start: typing.SupportsIndex | None = None,
	end: typing.SupportsIndex | None = None,
) -> int:
	if type(keys) is str: return orig.find(keys, start, end)
	result: list[int] = [orig.find(key, start, end) for key in keys]
	while -1 in result: result.remove(-1)
	return min(result, default=-1)


def parse_cmd_args(cmd: str|list[str]) -> list[str]:
	if type(cmd) is str: return shlex.split(cmd)
	elif type(cmd) is list: return cmd
	else: raise TypeError("unknown type for cmd")


def find_external(name: str) -> str:
	"""
	Find a linux executable path
	find_external("systemctl") = "/usr/bin/systemctl"
	find_external("service") = None
	"""
	return shutil.which(name)


def have_external(name: str) -> bool:
	"""
	Is a command in PATH
	find_external("systemctl") = True
	find_external("service") = False
	"""
	return shutil.which(name) is not None


def fd_get_path(fd: int) -> str | None:
	"""
	Get file path by FD
	fd_get_path(1) = "/dev/pts/0"
	"""
	link = f"/proc/self/fd/{fd}"
	if not os.path.exists(link): return None
	path = os.readlink(link)
	if not path.startswith("/"): return None
	if path.startswith("/memfd:"): return None
	if path.endswith(" (deleted)"): return None
	if not os.path.exists(path): return None
	return path


def size_to_bytes(value: str | int, alt_units: dict = None) -> int:
	units = {
		'b': 0.125, 'bit': 0.125, 'bits': 0.125, 'Bit': 0.125, 'Bits': 0.125,
		'B': 1, 'Byte': 1, 'Bytes': 1, 'bytes': 1, 'byte': 1,
		'k': 10**3, 'kB': 10**3, 'kb': 10**3, 'K': 2**10, 'KB': 2**10, 'KiB': 2**10,
		'm': 10**6, 'mB': 10**6, 'mb': 10**6, 'M': 2**20, 'MB': 2**20, 'MiB': 2**20,
		'g': 10**9, 'gB': 10**9, 'gb': 10**9, 'G': 2**30, 'GB': 2**30, 'GiB': 2**30,
		't': 10**12, 'tB': 10**12, 'tb': 10**12, 'T': 2**40, 'TB': 2**40, 'TiB': 2**40,
		'p': 10**15, 'pB': 10**15, 'pb': 10**15, 'P': 2**50, 'PB': 2**50, 'PiB': 2**50,
		'e': 10**15, 'eB': 10**15, 'eb': 10**15, 'E': 2**50, 'EB': 2**50, 'EiB': 2**50,
		'z': 10**15, 'zB': 10**15, 'zb': 10**15, 'Z': 2**50, 'ZB': 2**50, 'ZiB': 2**50,
		'y': 10**15, 'yB': 10**15, 'yb': 10**15, 'Y': 2**50, 'YB': 2**50, 'YiB': 2**50,
	}
	if type(value) is int: return value
	elif type(value) is str:
		if alt_units: units.update(alt_units)
		matches = {unit: len(unit) for unit in units if value.endswith(unit)}
		max_unit = max(matches.values(), default=0)
		unit = next((unit for unit in matches.keys() if matches[unit] == max_unit), None)
		mul = units[unit] if unit else 1.0
		return int(float(value[:len(value)-max_unit].strip()) * mul)
	else: raise TypeError("bad size value")


def bytes_pad(b: bytes, size: int, trunc: bool = False, pad: bytes = b'\0') -> bytes:
	l = len(b)
	if l > size and trunc: b = b[:size]
	if l < size: b += pad * (size - l)
	return b


def round_up(value: int, align: int) -> int:
	return (value + align - 1) & ~(align - 1)


def round_down(value: int, align: int) -> int:
	return value & ~(align - 1)


def open_config(path: str, mode=0o0644) -> io.TextIOWrapper:
	dist = f"{path}.dist"
	have_dist = False
	if os.path.exists(dist):
		have_dist = True
	elif os.path.exists(path):
		shutil.move(path, dist)
		have_dist = True
	flags = os.O_RDWR | os.O_CREAT | os.O_TRUNC
	fd = os.open(path=path, flags=flags, mode=mode)
	if fd < 0: raise IOError(f"open {path} failed")
	try:
		fp = os.fdopen(fd, "w")
		fp.write("# This file is auto generated by arch-image-builder\n")
		if have_dist:
			fn = os.path.basename(dist)
			fp.write(f"# Original file is {fn}\n")
		fp.write("\n")
		fp.flush()
	except:
		os.close(fd)
		raise
	return fp


def path_to_name(path: str) -> str:
	if path == "/": return "rootfs"
	if path.startswith("/"): path = path[1:]
	if len(path) <= 0: return "empty"
	return path.replace("/", "-")
